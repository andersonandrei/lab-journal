# -- mode: org --
# -- coding: utf-8 --
#+STARTUP: overview indent inlineimages logdrawer
#+TITLE:  Andrei's Journal
#+AUTHOR:      Andrei
#+LANGUAGE:    en
#+TAGS: noexport(n) Stats(S)
#+TAGS: Teaching(T) R(R) OrgMode(O) Python(P)
#+TAGS: Book(b) Code(C) Paper(P) Scheduler(S) Denis(d) Clément(c) Andrei(a) Qarnot(q)
#+TAGS: DataVis(v) PaperReview(W)
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* wednesday, 06-02-2019

** 18:02 Meeting, org-journal                                      :OrgMode:

*** Starting on org-journal
**** Trying o do something in the org-jornal1. 
***** Creating a list
     1. Hello
     2. Hi
     3. Salut
	1. Ça vá?
     4. Learning how to do some lists
     5. Creating a lot of topics

*** Todays meeting:
**** Specified each part in the project.
**** Actually, we have two main layers to keep attention: scheduler and allocation.
**** My work will be on the allocation: *DO THE FIRST VERSION OF THE SCHEDULER*:
***** For this, I will use some data from:
****** The INPUT (jobs)
******* Priority
******* Client
******* etc
****** The QBoxes (status from each QBOX):
******* Local data
******* Status(how full it is)

*** DONE LIST
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      
**** DONE Learn BatSim
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-07 qui 14:29]
- State "TODO"       from "WAITING"    [2019-02-07 qui 14:29]
- State "WAITING"    from "TODO"       [2019-02-07 qui 14:28] \\
  Waiting ...
***** WAITIGN Read about it
:END:      
*:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-07 qui 14:36] \\
  GBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:35]
:END:      
:END:
***** DONE First examples
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:* TODO Install
**** DONE Read two papers
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-13 qua 18:16]
- State "WAITING"    from "DONE"       [2019-02-11 seg 17:35]
- State "DONE"       from "TODO"       [2019-02-11 seg 17:35]
:END:      
***** DONE How future buildings...
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      
***** DONE Heating as a cloud...
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      

* thursday, 07-02-2019...
** Journal

*** Some tips with Pedro

**** Headers

**** Tags

**** etc

** Research

*** BATSIM

**** DONE First examples on BATSIM website
:LOGBOOK:  
- State "DONE"       from ""           [2019-02-08 sex 18:00]
- State "WAITING"    from "TODO"       [2019-02-07 qui 17:52] \\
  The installation is not working
:END:      

**** DONE First example on GitLab Prototype repo
DEADLINE: <2019-02-08 sex>
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-11 seg 17:33]
- State "WAITING"    from "TODO"       [2019-02-07 qui 17:52] \\
  The installation of BATSIM is not working
:
* friday, 08-02-2019
** Batsim
*** I installed it and performed the first example that includes: exectution and statistics.
*** If I understood well the structure. It is:
1. Batsim -> Simulates everything.
2. A scheduler -> Takes the decisions.

**** To see everything running, we can use 2 windows, one for each thing.
*NOTE:* Here, everything was setted to be in the /tmp.

#+NAME: batsim-side
#+BEGIN_SRC <bash> 
  batsim -p /tmp/batsim-v3.0.0/platforms/cluster512.xml        
         -w /tmp/batsim-v3.0.0/workloads/test_batsim_paper_workload_seed1.json
         -e "/tmp/expe-out/out"
#+END_SRC
It will keep the batsim oppened, waiting for the scheduler.

#+NAME: scheduler-side
#+BEGIN_SRC <bash>
  robin generate ./expe.yaml       
                    --output-dir=/tmp/expe-out       
                    --batcmd="batsim -p /tmp/batsim-v3.0.0/platforms/cluster512.xml 
                 -w /tmp/batsim-v3.0.0/workloads/test_batsim_paper_workload_seed1.json 
                 -e /tmp/expe-out/out"       
                    --schedcmd='batsched -v easy_bf'
#+END_SRC 
 It will use robin to run the scheduler batsched with the mode easy_bf.
** pybatsim
*** Runs a schedular for the batsim.
*** Configuration
**** To install by: pip install pybatsim
**** To clone [[https://gitlab.inria.fr/batsim/pybatsim][PyBatsim-repository]] to have access to the schedulers implemented there.
*** To run its scheduler:
**** To run the batsim as the same way.
**** To run the schedulers, acess the repository and try:
***** pybatsim schedulers/scheduler.py
**** I tried:
***** pybatsim schedulers/fillerSched.py
***** pybatsim schedulers/schedFcfs.py
** statistics
*** The batsim mainpage offer a example of statistic analysis:
#+BEGIN_LaTeX

#+END_LaTe
#+BEGIN_LaTeX

#+END_LaTeX
 #+NAME: batsim-analysis
 #+BEGIN_SRC sh
 #!/usr/bin/env Rscript
  library('tidyverse') # Use the tidyverse library.
  theme_set(theme_bw()) # Cosmetics.

  jobs = read_csv('out_jobs.csv') # Read the jobs file.

  # Manually compute some metrics on each job.
  jobs = jobs %>% mutate(slowdown = (finish_time - starting_time) /
                                  (finish_time - submission_time),
                       longer_than_one_minute = execution_time > 60)

  # Manually compute aggregated metrics.
  # Here, the mean waiting time/slowdown for jobs with small execution time.
  metrics = jobs %>% filter(longer_than_one_minute == FALSE) %>%
    summarize(mean_waiting_time = mean(waiting_time),
              mean_slowdown = mean(slowdown))

  print(metrics) # Print aggregated metrics.

  # Visualize what you want...
  # Is there a link between jobs' waiting time and size?
  ggplot(jobs) +
    geom_point(aes(y=waiting_time, x=requested_number_of_resources)) +
    ggsave('plot_wt_size.pdf')

  # Is this still true depending on job execution time?
  ggplot(jobs) +
    geom_point(aes(y=waiting_time, x=requested_number_of_resources)) +
    facet_wrap(~longer_than_one_minute) +
    ggsave('plot_wt_size_exectime.pdf')

  # Is there a link with job size and execution time?
  ggplot(jobs) +
    geom_violin(aes(factor(requested_number_of_resources), execution_time)) +
    ggsave('plot_exectime_size.pdf')

 #+END_SRC
*** Running this analysis on both pybatsimexamples we can check the different results.

* monday, 11-02-2019

** DONE To understand:
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:07]
:END:      

*** DONE The INPUT format for batsim;
:LOGBOOK:  
- State "DONE"       from "CANCELLED"  [2019-02-11 seg 17:07]
:END:      

*** DONE Some schedular examples;
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:07]
:END:

** The workflow:

*** Batsim-Scheduler communication:

**** Messages, JSON, via request-reply model:

***** Contraints format:

****** now

****** events

******* timestamp

******* type

******* data

****** And to differ the message, we change the *event type* as :

******* BIDIRECTIONAL

******* BATSIM => SCHEDULER

******* SCHEDULER => BATSIM

**** Workload:

***** The workload is an Input combined as:

****** Jobs: Users requests. It has:

******* id, subtime, res, profile, walltime, +
****** Profiles: Defines how the job execution should be simulated. It has:
******* type, etc. Where the type could be:
******** delay, prallel task, homogeneous pararllel task, etc.

*** Batsim requires to start:

**** a plataform; a workload; an output folder.

***** Providing a worload, it will have the jobs that should be scheduled.

**** Then, batsim will be learning, waiting for a scheduler to manage the jobs.

*** The scheduler:

**** Once the Batsim is already runnig, when we run the scheduler it will communicate with the Batsim by the messages, doing the requested decision.

**** The schdulers should implement all possible actions asked by the message types. For example: JobInitialize,kill,resquest. onBatSimInit,onJobSubmission, onJobCompletion.
*** An example:

**** I understood the fillerSched.py scheduler. It works following:

1. Initialize everything after Batsim intialized.
2. Schedule the jobs.
 2.2 _OnAfterBatsimInit_: // _Read_ a list of jobs *OpenJob* and a list of resources *availableResources* 
 2.1 _scheduleJobs_: // _Check_ all jobs in *OpenJob*
   2.1.1 _if_ (job.resourcesRequested > *aivailableResources*)
            discard it and remove from the *OpenJob*
   2.1.2 _else_
            scheduleJobs.append(job)
            *availableResources* -= jog.resourceRequested
            updateConsumptionTime
 2.2 _OnJobSubmission_:
  2.2.1 openJob.add(job)
  2.2.2 scheduleJobs()
 2.3 _OnJobCompletion_:
  2.3.1 *availableResources* += job.resourceRequested
  2.3.2 scheduleJobs()
**** I ran it as:
batsim -p platform52.xml -w test_batsim_paper_workload_seed1.json -e test-out-2
launcher.py scheduler/fillerSched.py

* terça, 12-02-2019
** DONE on Batsim
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:18]
:END:      
*** DONE Check about the data asked for the jobs. How to locate or transfer it.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 08:57]
:END:
**** It is done by writing and checking the NFS file after and before to write or to remove some data from some QBox.
** DONE on Papers
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:18]
:END:      

*** DONE Check on the Qarnot gitlab if there are some techniques for the schedulers.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:17]
:END:

**** There is a Deliverable2.2a that show the algortith to be implemented.
*** DONE Search some papers for schedulers on Cloud Computing
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:17]
:END:      
** TODO Source block configuration orgmode
:LOGBOOK:  
- State "TODO"       from ""           [2019-02-12 ter 12:54]
:END:
** TODO ESS library
:LOGBOOK:  
- State "TODO"       from ""           [2019-02-12 ter 12:56]
:END:
* wednesday, 13-02-2019
** Qarnot meeting
*** Administrative and update things with other teams.
*** About my part I should finish the current version of the QNodes scheduler. This way we will have a full system working.
*** With a full system working we will submit a paper to *SC2019*.
** Papers and techniques
*** I read the both papers that I selected on 06-02 and 12-02 and selected some algorthms to check later.
*** But, as our plan now is to finish the current scheduler version, I will work on the current code and think about improvements after (aka. read about techniques now).
* thursday, 14-02-2019
** DONE Modify the schedulers on pybatsim and compare the differences.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-15 sex 10:47]
:END:      
 I did it on the fillerSched. Now I will start to try to write a pseudocode for the QNodes scheduler.
* friday, 15-02-2019
** I should implement the algorithm of the Deliverable 2.2a. But, it asks for a function to predict the time to download a dataset for a specific QBox.
** I asked to Alex, by Slack, and he answered me that they do not have idea how to implement it now. So, I should skip it now, and after choose another rule to use.
** DONE Start to write a pseudocode to the algorithm on dlv.2.2a. 
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-15 sex 21:21]
:END:      
*** def schedule(self, job): 
        print("Haaaaaaaaaaeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeey-------\n")
        
        print("Job: ", job.id)
        print("Subtime: ", job.submit_time)
        print("Job.profile", job.profile)
        print("Profile", type(self.bs.profiles))
        list_of_datasets = {}
        for key in self.bs.profiles:
            print(self.bs.profiles[key][job.profile]['datasets'])
            qbox_key = job.profile
            list_of_datasets[qbox_key] = self.bs.profiles[key][job.profile]['datasets']

        for s in self.storage_controller._storages:
            st = self.storage_controller.get_storage(s)
            print("Datasets on Qbox: ", st.get_datas
*** It is current : 
**** getting the datasets asked by a job
**** listing all the storages on the StorageControl and its datasets.
** 
** TODO Talk with Clement
*** nix-shell https://github.com/oar-team/kapack/archive/master.tar.gz -A pybatsim
*** Cant found batsim using it.
*** 
*** On the batsim command: --events ../events/greco/events.json . There is no events.json on the folder.
*** 
*** Should I populate the Storage on the QNodeSched?
* monday, 18-02-2019
** I finished my first version of the list of QBoxes that already has the specified dataset.
** DONE 
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-19 ter 10:46]
:END:      
*** DONE Ask Clément
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-19 ter 10:45]
:END:      
**** Should I consider only one dataset per job and profile?
***** If more than one dataset per job: Should I do a matrix of QBoxes that has each dataset and chose the one that has more datasets?
***** No.
**** Should I consider a dataset as ["ds1"] or at the presented way ["QB...:inpu, QB:...:0, QB...:..."] ?
**** Can I commit and push my modifications in my branch on github?
***** Yes.
**** Mainly, I should put in the List only the QBoxes that already have ALL the required datasets from a job.
* tuesday, 19-02-2019
** TODO
*** Check to put the list_qboxes_with_datasets() on the StorageController.
*** Dispatche some jobs to some QBoxes to test.
* wednesday, 20-02-2019
** I attended the presentation:
*** David Shmoys: Models and algorithms for the Operation and Design of Bike-Sharing System
** I finished my report to HPC course.
* thursday, 21-02-2019
** Checked one more time the function to do the list L (the list of qboxes that already has the required datasets)
** Try to submitt the jobs to the QBoxes.
*** Here, the QNode uses onSubmission(job) to send it to the QBox.
*** It is receiving the message JOB_REJECTED. Maybe I need to use the "events" to change the event type of the jobs.
** Algorithm
*** Im thinking in:
**** for each job j:
***** sched = True
***** l = L(j)
***** if l != null:
****** qbox = maxHeatingReq(l):
****** if qbox == null:
******* qbox = l [ 0 ]
***** else :
****** qbox = maxHeating()
****** if qbox == null:
******* sched = False
***** if sched:
****** qbox =  max_requiringHeating()
***** else:
****** waitingList.append(j)
**** 
* friday, 22-02-2019
** TODO Verify how to:
*** DONE How to run a job, and why mine are been rejected?        :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:05] \\
  Ignore it now. I will start to work in the last version of the code.
:END:      
*** DONE Verify how to manage the instances of a job              :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "WAITING"    [2019-02-23 sáb 04:08] \\
  I need to confirm, but, as I understood, in the workload we have jobs like: 
    job 0 = {id=codeX-0 ...} job 1 = {id=codeX-1 ...} ... Job n = {id = codeX-n} }
  So, each job with id started with "codeX" , for real, are tasks for the same job.
  So, a job could be a unique job, or, if are composed by others, its not a job, it is a task.
  Then, we read the jobs as QTask().

  *YES*

- State "WAITING"    from "TODO"       [2019-02-22 sex 15:06] \\
  Is each instance a QTask on the new qarnotQNodeSched?
:END:
*** DONE Why the QTask now? What did change?                      :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "WAITING"    [2019-02-23 sáb 04:12] \\
  As I commit above, I think that these Taks are jobs that composes other bigger jobs.

  *YES*
:END:      
*** DONE Verify which qbox had preemption
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "TODO"       [2019-02-23 sáb 04:14] \\
  I need to confirm. But as I understood. There are nothing registrating if some QBox has preemption.
  By definition, preemption occurs when some executing job is stopped because another one with more priority arrives.
  I think I need to check, by the priority of each job, if I would put the current job in some QBoxes, 
  it would cause a preemption. So, I need to check the priority of the jobs that are already runnig in that QBox.

  *YES*
:END:
*** WAITING Verify the qbox that require more work for the next hour
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-22 sex 10:49] \\
  I did it, but not for the next hour exactly. I do not know how to check it.
  Also, I need to test it, but I do not know how to add heating requirement to a qbox.

  *??* CHECK IT
:END:
* saturday, 23-02-2019
** I think I understood some previous questions. They are in the TODO list of last day. So, I noted there what I think tha I understood.
* sunday, 24-02-2019
** I changeg the workload in use, putting the "real data" from the qarnot-examples.
** I started to do a function to get all indexes of jobs that compose the same main job.
*** This way, each job is thinked as a task, then, the idea is to dispatch as many as possible taks to the same qbox.
* monday, 25-02-2019
** I will start to work with the last version of the scheduler in the pybatsim-temperature branch.
** It uses QTask as the read input from the workload (aka. each input is a task and many tasks compose a job).
** This new one are implement almost the scheduler of the delivrable 2.2a. Like:
** TODO Algorithm peaces:
*** WAITING L <- List of QBOX that already has the required dataset. :Andrei:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:19] \\
  It is done in the previous scheduler. I should put it in the new one.
:END:      
*** WAITING Dispatch as many instances of j as possible on the selected QBox. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  Almost done. I should check.
:END:      
*** WAITING Check the priority to QBoxes that have available QRads without preemption. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  It is almost done. I should check.
:END:      
*** TODO Check the QBoxes that requires the most work in the next hour. :Qarnot:
*** TODO Download time prediction of the datasets                  :Qarnot:
*** TODO LQ <- List of QBoxes sorted as 1. and 2.
**** WAITING 1. The count of available QRads for the priority of j in descending order. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  It is almost done. I should check it.
:END:      
**** TODO 2. The predicted downloads time of the datasets.        :Qarnot:
** Andrei's algortihm:

'''
The idea is to order a waiting list of tasks by the profile.
Then, find a list of qboxes that already has the required data set. 
Then, for each qbox in this list, dispacth as many tasks, of the same profile, as possible.
  If there are not enough qboxes to dispatch this tasks, find another options, with other rule.
Update the list and start for the next group (ordered by profiles) of tasks.
'''

 waiting_lits
 ordered_l = waiting_lists.orderedByProfile()
 nb = len(ordered_l)
 while (nb > 0):

   #The amount of tasks with the same profiles, counted by the beginning of the list, until the first task with a different profile.
   nb_same_profile = get_nb_same_profile(ordered_l) 
   
   qboxes_for_profile = L(ordered_l[ 0 ])

   for qb in qboxes_for_profile:
     nqb = qb.resources
     if (nqb >= nb_same_profile):
       dispatch(ordered_l[0:nb_same_profile], qb)
     else:
       dispatch(ordered_l[0:nqb], qb)
       nb_same_profile -= nqb
       ordered_l = ordered_l[nqb:]
   
   if(nb_same_profile > 0):
     findQBoxAndDispatch()
     ordered_l = ordered_l[nb_same_profile:]
** New command                                                      :OrgMode:
*** To find and replace text: M + %
* tuesday, 26-02-2019
** DONE Implement the previous algorithm
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-26 ter 18:42]
- The structure are done. But BATSIM is not working with this version of scheduler. 
  So, I need to wait the fixes to check.
:END:
* wednesday, 27-02-2019
** TODO Work on
*** DONE the priority of QBoxes that have available QRads without preemption
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-01 sex 15:43]
:END:      
**** (aka. Run the taks using the priority levels: background, low and high.
*** CANCELLED the priority of QBoxes that requires the most work in the next hour
:LOGBOOK:  
- State "CANCELLED"  from "TODO"       [2019-02-27 qua 11:10]
:END:      
**** (skip it now)
*** DONE the count of available QRads for the priority of j in descending order
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-01 sex 15:44]
:END:      
**** (aka. The same as the first TODO)
*** WAITING the predicted download time of the data sets.
:LOGBOOK:  
- State "WAITING"    from "CANCELLED"  [2019-02-27 qua 11:10] \\
  Waiting the other team develop it.
- State "CANCELLED"  from "TODO"       [2019-02-27 qua 11:10]
:END:
*** DONE To merge my modifications on the StorageController with the Clément temperature branch.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-27 qua 17:17]
:END:      
*** DONE Organize the code. Use the doDispatch() as the main peace of the method schedule(). At the moment, it is duplicated.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-01 sex 15:44]
- [01-03-2019] As I found the error, I rewrote the code.
:END:      
* friday, 01-03-2019
** I found an erro in my last algorithm.
** Let's rewrite it. Done.
** Clément fixed batsim and changed something in the QNodeSched. I merged the codes.
** TODO Check on next monday, how to run this version ?
* saturday, 02-03-2019
** I added the structure to use the predicted download time of the data sets, when it is ready.
* monday, 04-03-2019
** DONE 
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-04 seg 18:23]
:END:      
*** DONE Run the updated batsim and qarnotNodeSched.py
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-04 seg 18:22]
:END:      
**** To run it, I copied the folder sample-data/simple from simulator-prototype to batsim to make it easier.
**** The command is: ./batsim -p ../sample-data/simple/platform_simple.xml -T 1 --enable-dynamic-jobs --events ../sample-data/simple/events_simple.json -w ../sample-data/simple/workload_simple.json
*** DONE Try to run mine and correct the possible *errors*
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-04 seg 18:22]
:END:      
**** DONE To decide if I will create a QTask using the job.profile, or if I will get it after using the task.job_id :Clément:
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-03-04 seg 15:47]
- I choose to add into the QTask() the profile. I should merge it with the main qarnotBoxSched.py
:END:
** I got a little error in the qarnotNodeSched.py. It is getting the number of slot of bkgd, low or hight priority for each qmobo :Clément:
** but, it is not verifying if the value is zero. So, the execution have never passed from the first priority case, bkgd.
*** Clément already fixed it in his official version.
** I ran my first version of the scheduler !!!!!!!!!!!!!!  
*** It is working. Now, the next step is to check some more workloads and compare the performance with the official one. 
