# -- mode: org --
# -- coding: utf-8 --
#+STARTUP: overview indent inlineimages logdrawer
#+TITLE:  Andrei's Journal
#+AUTHOR:      Andrei
#+LANGUAGE:    en
#+TAGS: noexport(n) Stats(S)
#+TAGS: Teaching(T) R(R) OrgMode(O) Python(P)
#+TAGS: Book(b) Code(C) Paper(P) Scheduler(S) Denis(d) Clément(c) Andrei(a) Qarnot(q)
#+TAGS: DataVis(v) PaperReview(W)
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* quarta, 06-02-2019

** 18:02 Meeting, org-journal                                      :OrgMode:

*** Starting on org-journal
**** Trying o do something in the org-jornal1. 
***** Creating a list
     1. Hello
     2. Hi
     3. Salut
	1. Ça vá?
     4. Learning how to do some lists
     5. Creating a lot of topics

*** Todays meeting:
**** Specified each part in the project.
**** Actually, we have two main layers to keep attention: scheduler and allocation.
**** My work will be on the allocation: *DO THE FIRST VERSION OF THE SCHEDULER*:
***** For this, I will use some data from:
****** The INPUT (jobs)
******* Priority
******* Client
******* etc
****** The QBoxes (status from each QBOX):
******* Local data
******* Status(how full it is)

*** DONE LIST
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      
**** DONE Learn BatSim
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-07 qui 14:29]
- State "TODO"       from "WAITING"    [2019-02-07 qui 14:29]
- State "WAITING"    from "TODO"       [2019-02-07 qui 14:28] \\
  Waiting ...
***** WAITIGN Read about it
:END:      
*:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-07 qui 14:36] \\
  GBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:35]
:END:      
:END:
***** DONE First examples
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:* TODO Install
**** DONE Read two papers
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-13 qua 18:16]
- State "WAITING"    from "DONE"       [2019-02-11 seg 17:35]
- State "DONE"       from "TODO"       [2019-02-11 seg 17:35]
:END:      
***** DONE How future buildings...
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      
***** DONE Heating as a cloud...
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:16]
:END:      

* quinta, 07-02-2019...
** Journal

*** Some tips with Pedro

**** Headers

**** Tags

**** etc

** Research

*** BATSIM

**** DONE First examples on BATSIM website
:LOGBOOK:  
- State "DONE"       from ""           [2019-02-08 sex 18:00]
- State "WAITING"    from "TODO"       [2019-02-07 qui 17:52] \\
  The installation is not working
:END:      

**** DONE First example on GitLab Prototype repo
DEADLINE: <2019-02-08 sex>
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-11 seg 17:33]
- State "WAITING"    from "TODO"       [2019-02-07 qui 17:52] \\
  The installation of BATSIM is not working
:
* sexta, 08-02-2019
** Batsim
*** I installed it and performed the first example that includes: exectution and statistics.
*** If I understood well the structure. It is:
1. Batsim -> Simulates everything.
2. A scheduler -> Takes the decisions.

**** To see everything running, we can use 2 windows, one for each thing.
*NOTE:* Here, everything was setted to be in the /tmp.

#+NAME: batsim-side
#+BEGIN_SRC <bash> 
  batsim -p /tmp/batsim-v3.0.0/platforms/cluster512.xml        
         -w /tmp/batsim-v3.0.0/workloads/test_batsim_paper_workload_seed1.json
         -e "/tmp/expe-out/out"
#+END_SRC
It will keep the batsim oppened, waiting for the scheduler.

#+NAME: scheduler-side
#+BEGIN_SRC <bash>
  robin generate ./expe.yaml       
                    --output-dir=/tmp/expe-out       
                    --batcmd="batsim -p /tmp/batsim-v3.0.0/platforms/cluster512.xml 
                 -w /tmp/batsim-v3.0.0/workloads/test_batsim_paper_workload_seed1.json 
                 -e /tmp/expe-out/out"       
                    --schedcmd='batsched -v easy_bf'
#+END_SRC 
 It will use robin to run the scheduler batsched with the mode easy_bf.
** pybatsim
*** Runs a schedular for the batsim.
*** Configuration
**** To install by: pip install pybatsim
**** To clone [[https://gitlab.inria.fr/batsim/pybatsim][PyBatsim-repository]] to have access to the schedulers implemented there.
*** To run its scheduler:
**** To run the batsim as the same way.
**** To run the schedulers, acess the repository and try:
***** pybatsim schedulers/scheduler.py
**** I tried:
***** pybatsim schedulers/fillerSched.py
***** pybatsim schedulers/schedFcfs.py
** statistics
*** The batsim mainpage offer a example of statistic analysis:
#+BEGIN_LaTeX

#+END_LaTe
#+BEGIN_LaTeX

#+END_LaTeX
 #+NAME: batsim-analysis
 #+BEGIN_SRC sh
 #!/usr/bin/env Rscript
  library('tidyverse') # Use the tidyverse library.
  theme_set(theme_bw()) # Cosmetics.

  jobs = read_csv('out_jobs.csv') # Read the jobs file.

  # Manually compute some metrics on each job.
  jobs = jobs %>% mutate(slowdown = (finish_time - starting_time) /
                                  (finish_time - submission_time),
                       longer_than_one_minute = execution_time > 60)

  # Manually compute aggregated metrics.
  # Here, the mean waiting time/slowdown for jobs with small execution time.
  metrics = jobs %>% filter(longer_than_one_minute == FALSE) %>%
    summarize(mean_waiting_time = mean(waiting_time),
              mean_slowdown = mean(slowdown))

  print(metrics) # Print aggregated metrics.

  # Visualize what you want...
  # Is there a link between jobs' waiting time and size?
  ggplot(jobs) +
    geom_point(aes(y=waiting_time, x=requested_number_of_resources)) +
    ggsave('plot_wt_size.pdf')

  # Is this still true depending on job execution time?
  ggplot(jobs) +
    geom_point(aes(y=waiting_time, x=requested_number_of_resources)) +
    facet_wrap(~longer_than_one_minute) +
    ggsave('plot_wt_size_exectime.pdf')

  # Is there a link with job size and execution time?
  ggplot(jobs) +
    geom_violin(aes(factor(requested_number_of_resources), execution_time)) +
    ggsave('plot_exectime_size.pdf')

 #+END_SRC
*** Running this analysis on both pybatsimexamples we can check the different results.

* segunda, 11-02-2019

** DONE To understand:
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:07]
:END:      

*** DONE The INPUT format for batsim;
:LOGBOOK:  
- State "DONE"       from "CANCELLED"  [2019-02-11 seg 17:07]
:END:      

*** DONE Some schedular examples;
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 seg 17:07]
:END:

** The workflow:

*** Batsim-Scheduler communication:

**** Messages, JSON, via request-reply model:

***** Contraints format:

****** now

****** events

******* timestamp

******* type

******* data

****** And to differ the message, we change the *event type* as :

******* BIDIRECTIONAL

******* BATSIM => SCHEDULER

******* SCHEDULER => BATSIM

**** Workload:

***** The workload is an Input combined as:

****** Jobs: Users requests. It has:

******* id, subtime, res, profile, walltime, +
****** Profiles: Defines how the job execution should be simulated. It has:
******* type, etc. Where the type could be:
******** delay, prallel task, homogeneous pararllel task, etc.

*** Batsim requires to start:

**** a plataform; a workload; an output folder.

***** Providing a worload, it will have the jobs that should be scheduled.

**** Then, batsim will be learning, waiting for a scheduler to manage the jobs.

*** The scheduler:

**** Once the Batsim is already runnig, when we run the scheduler it will communicate with the Batsim by the messages, doing the requested decision.

**** The schdulers should implement all possible actions asked by the message types. For example: JobInitialize,kill,resquest. onBatSimInit,onJobSubmission, onJobCompletion.
*** An example:

**** I understood the fillerSched.py scheduler. It works following:

1. Initialize everything after Batsim intialized.
2. Schedule the jobs.
 2.2 _OnAfterBatsimInit_: // _Read_ a list of jobs *OpenJob* and a list of resources *availableResources* 
 2.1 _scheduleJobs_: // _Check_ all jobs in *OpenJob*
   2.1.1 _if_ (job.resourcesRequested > *aivailableResources*)
            discard it and remove from the *OpenJob*
   2.1.2 _else_
            scheduleJobs.append(job)
            *availableResources* -= jog.resourceRequested
            updateConsumptionTime
 2.2 _OnJobSubmission_:
  2.2.1 openJob.add(job)
  2.2.2 scheduleJobs()
 2.3 _OnJobCompletion_:
  2.3.1 *availableResources* += job.resourceRequested
  2.3.2 scheduleJobs()
**** I ran it as:
batsim -p platform52.xml -w test_batsim_paper_workload_seed1.json -e test-out-2
launcher.py scheduler/fillerSched.py

* terça, 12-02-2019
** DONE on Batsim
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:18]
:END:      
*** DONE Check about the data asked for the jobs. How to locate or transfer it.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 08:57]
:END:
**** It is done by writing and checking the NFS file after and before to write or to remove some data from some QBox.
** DONE on Papers
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:18]
:END:      

*** DONE Check on the Qarnot gitlab if there are some techniques for the schedulers.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:17]
:END:

**** There is a Deliverable2.2a that show the algortith to be implemented.
*** DONE Search some papers for schedulers on Cloud Computing
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-13 qua 18:17]
:END:      
** TODO Source block configuration orgmode
:LOGBOOK:  
- State "TODO"       from ""           [2019-02-12 ter 12:54]
:END:
** TODO ESS library
:LOGBOOK:  
- State "TODO"       from ""           [2019-02-12 ter 12:56]
:END:
* quarta, 13-02-2019
** Qarnot meeting
*** Administrative and update things with other teams.
*** About my part I should finish the current version of the QNodes scheduler. This way we will have a full system working.
*** With a full system working we will submit a paper to *SC2019*.
** Papers and techniques
*** I read the both papers that I selected on 06-02 and 12-02 and selected some algorthms to check later.
*** But, as our plan now is to finish the current scheduler version, I will work on the current code and think about improvements after (aka. read about techniques now).
* quinta, 14-02-2019
** DONE Modify the schedulers on pybatsim and compare the differences.
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-15 sex 10:47]
:END:      
 I did it on the fillerSched. Now I will start to try to write a pseudocode for the QNodes scheduler.
* sexta, 15-02-2019
** I should implement the algorithm of the Deliverable 2.2a. But, it asks for a function to predict the time to download a dataset for a specific QBox.
** I asked to Alex, by Slack, and he answered me that they do not have idea how to implement it now. So, I should skip it now, and after choose another rule to use.
** DONE Start to write a pseudocode to the algorithm on dlv.2.2a. 
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-15 sex 21:21]
:END:      
*** def schedule(self, job): 
        print("Haaaaaaaaaaeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeey-------\n")
        
        print("Job: ", job.id)
        print("Subtime: ", job.submit_time)
        print("Job.profile", job.profile)
        print("Profile", type(self.bs.profiles))
        list_of_datasets = {}
        for key in self.bs.profiles:
            print(self.bs.profiles[key][job.profile]['datasets'])
            qbox_key = job.profile
            list_of_datasets[qbox_key] = self.bs.profiles[key][job.profile]['datasets']

        for s in self.storage_controller._storages:
            st = self.storage_controller.get_storage(s)
            print("Datasets on Qbox: ", st.get_datas
*** It is current : 
**** getting the datasets asked by a job
**** listing all the storages on the StorageControl and its datasets.
** 
** TODO Talk with Clement
*** nix-shell https://github.com/oar-team/kapack/archive/master.tar.gz -A pybatsim
*** Cant found batsim using it.
*** 
*** On the batsim command: --events ../events/greco/events.json . There is no events.json on the folder.
*** 
*** Should I populate the Storage on the QNodeSched?
* segunda 18-02-2019
** I finished my first version of the list of QBoxes that already has the specified dataset.
** DONE 
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-19 ter 10:46]
:END:      
*** DONE Ask Clément
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-19 ter 10:45]
:END:      
**** Should I consider only one dataset per job and profile?
***** If more than one dataset per job: Should I do a matrix of QBoxes that has each dataset and chose the one that has more datasets?
***** No.
**** Should I consider a dataset as ["ds1"] or at the presented way ["QB...:inpu, QB:...:0, QB...:..."] ?
**** Can I commit and push my modifications in my branch on github?
***** Yes.
**** Mainly, I should put in the List only the QBoxes that already have ALL the required datasets from a job.
* terça 19-02-2019
** TODO
*** Check to put the list_qboxes_with_datasets() on the StorageController.
*** Dispatche some jobs to some QBoxes to test.
* quarta 20-02-2019
** I attended the presentation:
*** David Shmoys: Models and algorithms for the Operation and Design of Bike-Sharing System
** I finished my report to HPC course.
* quinta 21-02-2019
** Checked one more time the function to do the list L (the list of qboxes that already has the required datasets)
** Try to submitt the jobs to the QBoxes.
*** Here, the QNode uses onSubmission(job) to send it to the QBox.
*** It is receiving the message JOB_REJECTED. Maybe I need to use the "events" to change the event type of the jobs.
** Algorithm
*** Im thinking in:
**** for each job j:
***** sched = True
***** l = L(j)
***** if l != null:
****** qbox = maxHeatingReq(l):
****** if qbox == null:
******* qbox = l [ 0 ]
***** else :
****** qbox = maxHeating()
****** if qbox == null:
******* sched = False
***** if sched:
****** qbox =  max_requiringHeating()
***** else:
****** waitingList.append(j)
**** 
* sexta 22-02-2019
** TODO Verify how to:
*** DONE How to run a job, and why mine are been rejected?        :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:05] \\
  Ignore it now. I will start to work in the last version of the code.
:END:      
*** DONE Verify how to manage the instances of a job              :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "WAITING"    [2019-02-23 sáb 04:08] \\
  I need to confirm, but, as I understood, in the workload we have jobs like: 
    job 0 = {id=codeX-0 ...} job 1 = {id=codeX-1 ...} ... Job n = {id = codeX-n} }
  So, each job with id started with "codeX" , for real, are tasks for the same job.
  So, a job could be a unique job, or, if are composed by others, its not a job, it is a task.
  Then, we read the jobs as QTask().

  *YES*

- State "WAITING"    from "TODO"       [2019-02-22 sex 15:06] \\
  Is each instance a QTask on the new qarnotQNodeSched?
:END:
*** DONE Why the QTask now? What did change?                      :Clément:
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "WAITING"    [2019-02-23 sáb 04:12] \\
  As I commit above, I think that these Taks are jobs that composes other bigger jobs.

  *YES*
:END:      
*** DONE Verify which qbox had preemption
:LOGBOOK:  
- State "DONE"       from "WAITING"    [2019-02-25 seg 11:05]
- State "WAITING"    from "TODO"       [2019-02-23 sáb 04:14] \\
  I need to confirm. But as I understood. There are nothing registrating if some QBox has preemption.
  By definition, preemption occurs when some executing job is stopped because another one with more priority arrives.
  I think I need to check, by the priority of each job, if I would put the current job in some QBoxes, 
  it would cause a preemption. So, I need to check the priority of the jobs that are already runnig in that QBox.

  *YES*
:END:
*** WAITING Verify the qbox that require more work for the next hour
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-22 sex 10:49] \\
  I did it, but not for the next hour exactly. I do not know how to check it.
  Also, I need to test it, but I do not know how to add heating requirement to a qbox.

  *??* CHECK IT
:END:
* sabado 23-02-2019
** I think I understood some previous questions. They are in the TODO list of last day. So, I noted there what I think tha I understood.
* domingo 24-02-2019
** I changeg the workload in use, putting the "real data" from the qarnot-examples.
** I started to do a function to get all indexes of jobs that compose the same main job.
*** This way, each job is thinked as a task, then, the idea is to dispatch as many as possible taks to the same qbox.
* segunda 25-02-2019
** I will start to work with the last version of the scheduler in the pybatsim-temperature branch.
** It uses QTask as the read input from the workload (aka. each input is a task and many tasks compose a job).
** This new one are implement almost the scheduler of the delivrable 2.2a. Like:
** TODO Algorithm peaces:
*** WAITING L <- List of QBOX that already has the required dataset. :Andrei:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:19] \\
  It is done in the previous scheduler. I should put it in the new one.
:END:      
*** WAITING Dispatch as many instances of j as possible on the selected QBox. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  Almost done. I should check.
:END:      
*** WAITING Check the priority to QBoxes that have available QRads without preemption. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  It is almost done. I should check.
:END:      
*** TODO Check the QBoxes that requires the most work in the next hour. :Qarnot:
*** TODO Download time prediction of the datasets                  :Qarnot:
*** TODO LQ <- List of QBoxes sorted as 1. and 2.
**** WAITING 1. The count of available QRads for the priority of j in descending order. :Clément:
:LOGBOOK:  
- State "WAITING"    from "TODO"       [2019-02-25 seg 11:20] \\
  It is almost done. I should check it.
:END:      
**** TODO 2. The predicted downloads time of the datasets.        :Qarnot:
